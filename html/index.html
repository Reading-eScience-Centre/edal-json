<!doctype html>
<html>
<head>
	<title></title>
	<meta charset="utf-8">
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
	
	<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
	<script src="https://cdn.rawgit.com/acigna/jquery-ajax-native/1.0.1/src/jquery-ajax-native.js"></script>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet-src.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.0.29/leaflet-providers.min.js"></script>
	<!--
	<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.3.6/proj4.js"></script>
	<script src="https://cdn.rawgit.com/kartena/Proj4Leaflet/0.7.1/src/proj4leaflet.js"></script>
	<script src="polarmap-src.js"></script>
	-->
	
	<script src="js/ndarray.js"></script>
	<script src="js/palettes.js"></script>
	<script src="js/interpolation.js"></script>
	<script src="js/msgpack.js"></script>
	
	<style>
		html, body { height: 98%; }
		#map { height: 100%; }
		
		.info {
			padding: 6px 8px;
			font: 14px/16px Arial, Helvetica, sans-serif;
			background: white;
			background: rgba(255,255,255,0.8);
			box-shadow: 0 0 15px rgba(0,0,0,0.2);
			border-radius: 5px;
		}
		.legend {
			text-align: left;
			line-height: 18px;
			color: #555;
		}
		.legend i {
			width: 18px;
			height: 18px;
			float: left;
			margin-right: 8px;
			opacity: 0.7;
		}
		.button-active {
			font-weight: bold;
		}
	</style>
</head>
<body>
	<div id="map"></div>
	
	<template id="template-legend">
		<div class="info legend">
			<div style="margin-bottom:3px">
				<strong class="legend-title"></strong> (<span class="legend-uom"></span>)
			</div>
			<div style="display: inline-block; height: 144px; float:left">
				<span style="height: 136px; width: 18px; display: block; margin-top: 9px;" class="legend-palette"></span>
			</div>
			<div style="display: inline-block; float:left; height:153px">
				<table style="height: 100%;">
					<tr><td style="vertical-align:top" class="legend-max"></td></tr>
					<tr><td style="vertical-align:bottom" class="legend-min"></td></tr>
				</table>
			</div>
		</div>
	</template>
	
	<template id="template-palettes">
		<div class="info palettes">
			Palette:
			<button class="palette-button" data-palette="dem">DEM</button>
			<button class="palette-button" data-palette="gray">Grayscale</button>
			<button class="palette-button" data-palette="rainbow">Rainbow</button>
			<button class="palette-button" data-palette="linearL">LinearL</button>
		</div>
	</template>
	
	<template id="template-interpolation">
		<div class="info interpolation">
			Interpolation:
			<button class="interpolation-button" data-interpolation="nearestNeighbor">None</button>
			<button class="interpolation-button" data-interpolation="idw">IDW</button>
		</div>
	</template>
	
	<template id="template-palette-range">
		<div class="info palette-range">
			Palette Range:
			<button class="palette-range-button" data-palette-range="global">Global</button>
			<button class="palette-range-button" data-palette-range="fov">Field of view</button>
			<button class="palette-range-button" data-palette-range="custom">Custom</button>
		</div>
	</template>

	<script>
	var ndarray = require("ndarray");
	
	var map = L.map('map').setView([10, 0], 2);	
	
	var baseLayers = {
		'Esri.WorldImagery': 'Esri Satellite',		
		'Esri.WorldShadedRelief': 'Esri Shaded Relief',
		'Esri.OceanBasemap': 'Esri Ocean',
		'Esri.WorldGrayCanvas': 'Esri Gray',
		'OpenStreetMap': 'OpenStreetMap',
		'Stamen.Watercolor': 'Stamen Watercolor',
		'NASAGIBS.ViirsEarthAtNight2012': 'VIIRS City Lights 2012'
	};
	var layerControl = {};
	Object.keys(baseLayers).forEach(function (id) {
		var layer = L.tileLayer.provider(id);
		layerControl[baseLayers[id]] = layer;
	});
	layerControl[baseLayers['Esri.WorldImagery']].addTo(map);
	var lc = L.control.layers(layerControl).addTo(map);
	
	function redrawLayers(map) {
		map.eachLayer(function (layer) {
			if ('drawTile' in layer) {
				map.removeLayer(layer);
				map.addLayer(layer);
			}
		});
	}
	
	// default palette, note that map.palette is our own attribute
	var defaultPalette = 'rainbow';
	var defaultInterpolation = 'nearestNeighbor';
	map.palette = palettes[defaultPalette];
	map.interpolation = interpolationMethods[defaultInterpolation];
	
	var paletteSwitcher = L.control({position: 'bottomleft'});
	paletteSwitcher.onAdd = function (map) {
		var div = document.importNode($('#template-palettes')[0].content, true);
		div = $('.palettes', div)[0];
		$(".palette-button[data-palette='" + defaultPalette + "']",div).addClass('button-active');
		$('.palette-button', div).click(function() {
			map.palette = palettes[$(this).data('palette')];
			$('.palette-button').removeClass('button-active');
			$(this).addClass('button-active');
			redrawLayers(map);
		});
		return div;
	};
		
	var paletteRangeControl = L.control({position: 'bottomleft'});
	paletteRangeControl.onAdd = function (map) {
		var div = document.importNode($('#template-palette-range')[0].content, true);
		div = $('.palette-range', div)[0];
		$('.palette-range-button', div).click(function() {
			var action = $(this).data('palette-range');
			map.eachLayer(function (layer) {
				if (!('drawTile' in layer)) return;
				var range = layer.featureResult.range[layer.paramId];
				if (action == "global") {
					delete range.min;
					delete range.min;
				} else if (action == "fov") {
					// TODO recalculate range for current field-of-view
					// first, get current bounding box
				} else if (action == "custom") {
					// TODO display popup to set range extent for each layer
				}
			});			
			redrawLayers(map);
		});
		return div;
	};
	
	var interpolationSwitcher = L.control({position: 'bottomleft'});
	interpolationSwitcher.onAdd = function (map) {
		var div = document.importNode($('#template-interpolation')[0].content, true);
		div = $('.interpolation', div)[0];
		$(".interpolation-button[data-interpolation='" + defaultInterpolation + "']",div).addClass('button-active');
		$('.interpolation-button', div).click(function() {
			map.interpolation = interpolationMethods[$(this).data('interpolation')];
			$('.interpolation-button').removeClass('button-active');
			$(this).addClass('button-active');
			redrawLayers(map);
		});
		return div;
	};
	paletteSwitcher.addTo(map);
	paletteRangeControl.addTo(map);
	interpolationSwitcher.addTo(map);
	
	function createLegend(palette, title, low, high, uom) {
		var legend = L.control({position: 'bottomright'});
		
		legend.onAdd = function (map) {
			var div = document.importNode($('#template-legend')[0].content, true);
			div = $('.legend', div)[0];
			$('.legend-title', div).html(title);
			$('.legend-uom', div).html(uom);
			$('.legend-min', div).html(low);
			$('.legend-max', div).html(high);
			
			var colors = palette.allowedValues;
			var gradient = "";
			for (var i=0; i<colors.ncolors; i++) {
				if (i>0) gradient+= ",";
				gradient+= "rgb(" + colors.red[i] + "," + colors.green[i] + "," + colors.blue[i] + ")";
			}
			$('.legend-palette', div).css('background', 
			                              'transparent linear-gradient(to top, ' + gradient + ') repeat scroll 0% 0%');
			return div;
		};
		return legend;
	}
		
	map.on('overlayadd', function (e) {
		// As we lazy-load range data within drawTile, the range extent may not have been
		// calculated yet. As a quick work-around, we introduce a delay here.
		// A better solution would be to have an initialization function when a adding
		// a layer and an event that would need to be fired once done. After that, the
		// tile drawing could start. However, leaflet doesn't support that yet.
		
		setTimeout(function() {
			var layer = e.layer;
			var rangeType = layer.featureResult.rangeType[layer.paramId];
			var range = layer.featureResult.range[layer.paramId];
			var legend = createLegend(map.palette, rangeType.title, range.min.toFixed(2), range.max.toFixed(2), rangeType.uom);
			legend.addTo(map);
			layer.legend = legend;
		}, 3000);
	});
	
	map.on('overlayremove', function (e) {
		var layer = e.layer;
		map.removeControl(layer.legend);
	});
	
	// the following assumes a rectilinear data grid
		
	var supportedCrs = {
		"http://www.opengis.net/def/crs/OGC/1.3/CRS84": {}
	};	
	
	function drawTileFn(layer, paramId) {
		function drawTile(canvas, tilePoint, zoom) {
			var ctx = canvas.getContext('2d');
			var tileSize = this.options.tileSize;
			var result = this.featureResult; // our own little cache
			
			var param = result.range[paramId];
			
			// calculate and cache range extent if not provided
			if (!('min' in param)) {
				var extent = arrayMinMax(param.values);
				param.min = extent.min;
				param.max = extent.max;
			}

			// projection coordinates of top left tile pixel
			var start = tilePoint.multiplyBy(tileSize);
			var startX = start.x;
			var startY = start.y;
			
			// array shape
			// we only support CRS84 here for now (lon-lat order)
			var nLon = result.domain.x.length;
			var nLat = result.domain.y.length;
			var nVertical = 'vertical' in result.domain ? result.domain.vertical.length : 1;
			var nTime = 'time' in result.domain ? result.domain.time.length : 1;
			
			var paramArr = ndarray(param.values, [nTime,nVertical,nLat,nLon]);
			// TODO expose time/height choice via UI
			paramArr = paramArr.pick(0,0,null,null);
			
			// store for faster access
			var domainLon = result.domain.x;
			var domainLat = result.domain.y;
			var domainBbox = result.domain.bbox;
			var lonRange = [result.domain.lonDiscontinuity, result.domain.lonDiscontinuity+360];
			var paletteRed = map.palette.allowedValues.red;
			var paletteGreen = map.palette.allowedValues.green;
			var paletteBlue = map.palette.allowedValues.blue;
			var interp = map.interpolation.fn;
			
			var tLoop = Date.now();
			
			
			var bigDomain = false;
			if (bigDomain) {
				// use subset of domain/values based on bounding box
				// will speed up indexOfNearest
				// TODO check if this is really the case for bigger datasets
				var tileTopLeftGeo = map.unproject(start);
				var tileBottomRightGeo = map.unproject(L.point(startX+tileSize, startY+tileSize));
				
				tileTopLeftGeo.lng = wrapLongitude(tileTopLeftGeo.lng, lonRange);
				tileBottomRightGeo.lng = wrapLongitude(tileBottomRightGeo.lng, lonRange);
				if (tileBottomRightGeo.lng < tileTopLeftGeo.lng) {
					// unwrap lng after wrapping, so that both are in right order again
					tileBottomRightGeo.lng+= 360;
				}
				var iLonStart = indexOfNearest(domainLon, tileTopLeftGeo.lng);
				var iLonEnd = indexOfNearest(domainLon, tileBottomRightGeo.lng);
				var iLatStart = indexOfNearest(domainLat, tileBottomRightGeo.lat);
				var iLatEnd = indexOfNearest(domainLat, tileTopLeftGeo.lat);
				domainLon = domainLon.slice(iLonStart, iLonEnd+1); // could use ndarray here as well
				domainLat = domainLat.slice(iLatStart, iLatEnd+1);
				paramArr = paramArr.hi(iLatEnd+1,iLonEnd+1).lo(iLatStart,iLonStart);
			}
			
			var imgData = ctx.getImageData(0, 0, tileSize, tileSize);
			// Uint8ClampedArray, 1-dimensional, in order R,G,B,A,R,G,B,A,... row-major
			var rgba = ndarray(imgData.data, [tileSize,tileSize,4]);
			
			
			var tNear = 0;
			var tUnproject = 0;
						
			function setPixel(tileY, tileX, val) {
				// map value to color using a palette
				// scale val to [0,255] using the range extent
				// (IDL bytscl formula: http://www.exelisvis.com/docs/BYTSCL.html)
				valScaled = Math.trunc((255 + 0.9999) * (val - param.min)/(param.max - param.min));
				
				rgba.set(tileY,tileX,0,paletteRed[valScaled]);
				rgba.set(tileY,tileX,1,paletteGreen[valScaled]);
				rgba.set(tileY,tileX,2,paletteBlue[valScaled]);
				rgba.set(tileY,tileX,3,255);
			}
			
			function drawAnyProjection() {
				// TODO rewrite with interpolation support like drawMercator
				// usable for any map projection, but computationally more intensive
				
				// TODO there are two hotspots in the loop: map.unproject and indexOfNearest
				
				for (var tileX=0; tileX<tileSize; tileX++) {				
					for (var tileY=0; tileY<tileSize; tileY++) {
						// get geographic coordinates of tile pixel
						var posGeo = map.unproject(L.point(startX+tileX, startY+tileY));
						
						var lat = posGeo.lat,
						    lon = posGeo.lng;
						
						// we first check whether the tile pixel is outside the domain bounding box
						// in that case we skip it as we do not want to extrapolate
						if (lat < domainBbox[1] || lat > domainBbox[3]) {
							continue;
						}
							
						lon = wrapLongitude(lon, lonRange);
						if (lon < domainBbox[0] || lon > domainBbox[2]) {
							continue;
						}
						
						// now we find the closest grid cell using simple binary search
						// for finding the closest latitude/longitude we use a simple binary search
						// (as the array is always ascending and there is no discontinuity)
						//var t0 = Date.now();
						var iLatNeighbors = indicesOfNearest(domainLat, lat);
						var iLonNeighbors = indicesOfNearest(domainLon, lon);
						//tNear += Date.now()-t0;
											
						// now we fetch the range value at the given grid cell
						var val = interp(paramArr, lon, lat, domainLon, domainLat, iLonNeighbors, iLatNeighbors);
						if (val === null) {
							continue;
						}
						
						setPixel(tileY, tileX, val);
					}
				}
			}
			
			function drawMercator() {
				// optimized version for mercator-like projections
				// this can be used when lat and long can be computed independently for a given pixel
							
				var latCache = new Array(tileSize);
				var iLatNeighborsCache = new Array(tileSize);
				for (var tileY=0; tileY<tileSize; tileY++) {
					var lat = map.unproject(L.point(startX, startY+tileY)).lat;
					latCache[tileY] = lat;
					// find the index of the closest latitude in the grid using simple binary search
					iLatNeighborsCache[tileY] = indicesOfNearest(domainLat, lat);
				}
				
				for (var tileX=0; tileX<tileSize; tileX++) {
					var lon = map.unproject(L.point(startX+tileX, startY)).lng;
					lon = wrapLongitude(lon, lonRange);
					if (lon < domainBbox[0] || lon > domainBbox[2]) {
						continue;
					}
					// find the index of the closest longitude in the grid using simple binary search
					// (as the array is always ascending and there is no discontinuity)
					var iLonNeighbors = indicesOfNearest(domainLon, lon);
					
					for (var tileY=0; tileY<tileSize; tileY++) {
						// get geographic coordinates of tile pixel
						var lat = latCache[tileY];
						
						// we first check whether the tile pixel is outside the domain bounding box
						// in that case we skip it as we do not want to extrapolate
						if (lat < domainBbox[1] || lat > domainBbox[3]) {
							continue;
						}
						
						var iLatNeighbors = iLatNeighborsCache[tileY];
						
						// now we fetch the range value at the given grid cell						
						var val = interp(paramArr, lon, lat, domainLon, domainLat, iLonNeighbors, iLatNeighbors);
						if (val === null) {
							continue;
						}
						
						setPixel(tileY, tileX, val);
					}
				}
			}
			
			// TODO check which projection is active and switch if needed
			drawMercator();
			//drawAnyProjection();
			
			//console.log("tile loop, unproject", tUnproject);
			//console.log("tile loop, indexofnearest", tNear);
			//console.log("tile loop", Date.now()-tLoop);
			
			ctx.putImageData(imgData, 0, 0);
		}
		// the following lazy-loads range values
		return function(canvas, tilePoint, zoom) {
			var self = this;
			var paramRange = layer.featureResult.range[paramId];
			if ('values' in paramRange) {
				drawTile.call(self, canvas, tilePoint, zoom);
			} else {
				$.ajax({
					dataType: 'native',
					accepts: {
						'native': 'application/x-msgpack'
					},
					url: paramRange.id,
					xhrFields: {
					  responseType: 'arraybuffer'
					},
					success: function( raw ) {
						var paramRangeWithValues = msgpack.unpack(new Uint8Array(raw));
						layer.featureResult.range[paramId] = paramRangeWithValues;
						drawTile.call(self, canvas, tilePoint, zoom);
					}
				});
				/*
				$.getJSON(paramRange.id, function( paramRangeWithValues ) {
					layer.featureResult.range[paramId] = paramRangeWithValues;
					drawTile.call(self, canvas, tilePoint, zoom);
				});*/
			}
		};
	}
	
	function arrayMinMax(arr) {
		var len = arr.length, min = Infinity, max = -Infinity;
		while (len--) {
			var el = arr[len];
			if (el == null) {
				// do nothing
			} else if (el < min) {
				min = el;
			} else if (el > max) {
				max = el;
			}
		}
		return {min: min, max: max};
	};
	
	function indicesOfNearest(a, x) {
		// return the indices of the two neighbors closest to x 
		// if x exists in the array, both neighbors point to x
		// adapted from https://stackoverflow.com/a/4431347
		var lo = -1, hi = a.length;
		while (hi - lo > 1) {
			var mid = Math.round((lo + hi)/2);
			if (a[mid] <= x) {
				lo = mid;
			} else {
				hi = mid;
			}
		}
		if (a[lo] == x) hi = lo;
		return [lo,hi];
	}
	
	function indexOfNearest(a, x) {
		var i = indicesOfNearest(a, x);
		var lo = i[0], hi = i[1];
		if (Math.abs(x-a[lo]) < Math.abs(x-a[hi])) {
			return lo;
		} else {
			return hi;
		}
	}
	
	function wrapLongitude(lon, range) {
		return wrapNum(lon, range, true);
	}
	
	// stolen from https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js
	// doesn't exist in current release (0.7.3)
	function wrapNum(x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	}
	
	function wrapLongitudes(domain) {
		// we assume WGS84 with lon-lat order (CRS84)
		var containsDiscontinuity = domain.bbox[0] > domain.bbox[2];
		if (containsDiscontinuity) {
			// TODO wrap longitudes to new range without discontinuity
			alert("discontinuity detected, not implemented yet");
		}
		
		domain.lonDiscontinuity = domain.bbox[0];
	}
	
	function addFeature(url) {
		$.getJSON(url, function(featureData) {
			var result = featureData.result;
			if (!(result.domain.crs in supportedCrs)) {
				alert("Sorry, only the CRS84 coordinate reference system is currently supported. Yours is: " + result.domain.crs);
				return;
			}
			result.domain.x = new Int16Array(result.domain.x);
			result.domain.y = new Int8Array(result.domain.y);
			wrapLongitudes(result.domain);
			// create a canvas layer for each parameter
			for (paramId in result.rangeType) {
				var canvasTiles = L.tileLayer.canvas();
				canvasTiles.drawTile = drawTileFn(canvasTiles, paramId);
				canvasTiles.featureResult = result;
				canvasTiles.paramId = paramId;
				lc.addOverlay(canvasTiles, result.rangeType[paramId].title);
			}
		});
	}
	
	addFeature("http://localhost:8182/datasets/foam_one_degree-2011-01-01.nc/features/ICEC");
	addFeature("http://localhost:8182/datasets/foam_one_degree-2011-01-01.nc/features/TMP");
	addFeature("http://localhost:8182/datasets/foam_one_degree-2011-01-01.nc/features/SALTY");
	addFeature("http://localhost:8182/datasets/foam_one_degree-2011-01-01.nc/features/M");
	addFeature("http://localhost:8182/datasets/20100715-UKMO-L4HRfnd-GLOB-v01-fv02-OSTIA.nc/features/analysed_sst")
	addFeature("http://localhost:8182/datasets/en3_test_data.nc/features/7880:C:%5CUsers%5Cnx910562%5Cgit%5Cedal-json%5Ctarget%5Cclasses%5Cen3_test_data.nc");
	</script>
</body>
</html>